# -*- coding: utf-8 -*-
"""extractive_QA_zero_shot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_vnclHTdbwAhJZ0PkB-aABKc0TePwldu

I. TASK: Extractive Question Answering

https://huggingface.co/course/chapter7/7?fw=pt

II. PRETRAINED MODEL: BERTa

https://huggingface.co/projecte-aina/roberta-base-ca-v2

https://github.com/projecte-aina/club

BERTa for Extractive-QA:

https://huggingface.co/projecte-aina/roberta-base-ca-cased-qa

III. DATA: CatalanQA


**Data Fields**

Follows (Rajpurkar, Pranav et al., 2016) for SQuAD v1 datasets:

- id (str): Unique ID assigned to the question.
- title (str): Title of the article.
- context (str): Article text.
- question (str): Question.
- answers (list): Answer to the question, containing:
 - text (str): Span text answering to the question.
 - answer_start Starting offset of the span text answering to the question.

**Data Splits**

- train.json: 17135 question/answer pairs
- dev.json: 2157 question/answer pairs
- test.json: 2135 question/answer pairs

https://huggingface.co/datasets/projecte-aina/catalanqa

#1. Setting the environment
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install transformers

import transformers

print(transformers.__version__)

import tensorflow as tf
import torch
device_name = tf.test.gpu_device_name()
if device_name != '/device:GPU:0':
  raise SystemError('GPU device not found')
print('Found GPU at: {}'.format(device_name))
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
n_gpu = torch.cuda.device_count()
torch.cuda.get_device_name(0)

"""#2. Loading the data"""

!pip install datasets

from datasets import load_dataset

# define the datasets ENGLISH

path_en = "/content/drive/My Drive/APP1/"

script_en = "/content/drive/My Drive/APP1/englishqa.py"

data_files_en = {"train": path_en + "train_en.json",
                 "dev": path_en + "train_en.json",
                 "test": path_en + "train_en.json"
             }

raw_datasets_en = load_dataset(script_en, data_files=data_files_en)

raw_datasets_en

from transformers import set_seed

transformers.set_seed(42)

import random

# Get the indices of 17000 random examples from the English train split (to reduce the amount of computing power needed)
indices_en = random.sample(range(len(raw_datasets_en['train'])), 17000)

# Select the examples at the random indices
raw_datasets_en['train'] = raw_datasets_en['train'].select(indices_en)

raw_datasets_en

raw_datasets_en["train"][0]

# define the datasets CATALAN

path_ca = "/content/drive/My Drive/APP1/"

script_ca = "/content/drive/My Drive/APP1/catalanqa.py"

data_files_ca = {"train": path_ca + "train_cat.json",
             "dev": path_ca + "dev_cat.json",
             "test": path_ca + "test_cat.json"}

raw_datasets_ca = load_dataset(script_ca, data_files=data_files_ca)

raw_datasets_ca

# Remove all examples from the Catalan train split for the zero-shot approach
indices = random.sample(range(len(raw_datasets_ca['train'])), 0)

# Select the examples at the random indices
raw_datasets_ca['train'] = raw_datasets_ca['train'].select(indices)

raw_datasets_ca

# get a new dataset containing EN ['train'] dataset for training, and the CA ['validation] and ['test'] for validation and test

from datasets import DatasetDict, concatenate_datasets

train_en = raw_datasets_en["train"]
train_ca = raw_datasets_ca["train"]

train_enca = concatenate_datasets([train_en, train_ca])

# create a new DatasetDict with the three splits you want
raw_datasets = DatasetDict({
    "train": train_enca,
    "validation": raw_datasets_ca["validation"],
    "test": raw_datasets_ca["test"]
})

raw_datasets

# sample of English instance in train split
raw_datasets["train"][0]

print("Sample instance:", raw_datasets["train"][0])

print("Context: ", raw_datasets["train"][0]["context"])
print("Question: ", raw_datasets["train"][0]["question"])
print("Answer: ", raw_datasets["train"][0]["answers"])

"""#3. Preprocessing the training data"""

from transformers import AutoTokenizer

# choose the model_checkpoint for the tokeniser and pretrained model

model_checkpoint = "xlm-roberta-base"
#model_checkpoint = "projecte-aina/roberta-base-ca-v2"

tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)

# make sure our model_checkpoint is supported for fast tokeniser
tokenizer.is_fast

# check tokenisation with 1 sample
context = raw_datasets["train"][0]["context"]
question = raw_datasets["train"][0]["question"]

inputs = tokenizer(question, context)
tokenizer.decode(inputs["input_ids"])

inputs = tokenizer(
    question,
    context,
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
)

for ids in inputs["input_ids"]:
    print(tokenizer.decode(ids))

inputs = tokenizer(
    question,
    context,
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
    return_offsets_mapping=True,
)
inputs.keys()

inputs["overflow_to_sample_mapping"]

# check with several samples

inputs = tokenizer(
    raw_datasets["train"][2:6]["question"],
    raw_datasets["train"][2:6]["context"],
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
    return_offsets_mapping=True,
)

print(f"The 4 examples gave {len(inputs['input_ids'])} features.")
print(f"Here is where each comes from: {inputs['overflow_to_sample_mapping']}.")

answers = raw_datasets["train"][2:6]["answers"]
start_positions = []
end_positions = []

for i, offset in enumerate(inputs["offset_mapping"]):
    sample_idx = inputs["overflow_to_sample_mapping"][i]
    answer = answers[sample_idx]
    start_char = answer[0]["answer_start"]
    end_char = answer[0]["answer_start"] + len(answer[0]["text"])
    sequence_ids = inputs.sequence_ids(i)

    # Find the start and end of the context
    idx = 0
    while sequence_ids[idx] != 1:
        idx += 1
    context_start = idx
    while sequence_ids[idx] == 1:
        idx += 1
    context_end = idx - 1

    # If the answer is not fully inside the context, label is (0, 0)
    if offset[context_start][0] > start_char or offset[context_end][1] < end_char:
        start_positions.append(0)
        end_positions.append(0)
    else:
        # Otherwise it's the start and end token positions
        idx = context_start
        while idx <= context_end and offset[idx][0] <= start_char:
            idx += 1
        start_positions.append(idx - 1)

        idx = context_end
        while idx >= context_start and offset[idx][1] >= end_char:
            idx -= 1
        end_positions.append(idx + 1)

start_positions, end_positions

idx = 0
sample_idx = inputs["overflow_to_sample_mapping"][idx]
answer = answers[sample_idx][0]["text"]

start = start_positions[idx]
end = end_positions[idx]
labeled_answer = tokenizer.decode(inputs["input_ids"][idx][start : end + 1])

print(f"Theoretical answer: {answer}, labels give: {labeled_answer}")

idx = 4
sample_idx = inputs["overflow_to_sample_mapping"][idx]
answer = answers[sample_idx][0]["text"]

decoded_example = tokenizer.decode(inputs["input_ids"][idx])
print(f"Theoretical answer: {answer}, decoded example: {decoded_example}")

# define function with all the steps seen above to preprocess the training set

max_length = 384
stride = 128


def preprocess_training_examples(examples):
    questions = [q.strip() for q in examples["question"]]
    inputs = tokenizer(
        questions,
        examples["context"],
        max_length=max_length,
        truncation="only_second",
        stride=stride,
        return_overflowing_tokens=True,
        return_offsets_mapping=True,
        padding="max_length",
    )

    offset_mapping = inputs.pop("offset_mapping")
    sample_map = inputs.pop("overflow_to_sample_mapping")
    answers = examples["answers"]
    start_positions = []
    end_positions = []

    for i, offset in enumerate(offset_mapping):
        sample_idx = sample_map[i]
        answer = answers[sample_idx]
        start_char = answer[0]["answer_start"]
        end_char = answer[0]["answer_start"] + len(answer[0]["text"])
        sequence_ids = inputs.sequence_ids(i)

        # Find the start and end of the context
        idx = 0
        while sequence_ids[idx] != 1:
            idx += 1
        context_start = idx
        while sequence_ids[idx] == 1:
            idx += 1
        context_end = idx - 1

        # If the answer is not fully inside the context, label is (0, 0)
        if offset[context_start][0] > start_char or offset[context_end][1] < end_char:
            start_positions.append(0)
            end_positions.append(0)
        else:
            # Otherwise it's the start and end token positions
            idx = context_start
            while idx <= context_end and offset[idx][0] <= start_char:
                idx += 1
            start_positions.append(idx - 1)

            idx = context_end
            while idx >= context_start and offset[idx][1] >= end_char:
                idx -= 1
            end_positions.append(idx + 1)

    inputs["start_positions"] = start_positions
    inputs["end_positions"] = end_positions
    return inputs

train_dataset = raw_datasets["train"].map(
    preprocess_training_examples,
    batched=True,
    remove_columns=raw_datasets["train"].column_names,
)
len(raw_datasets["train"]), len(train_dataset)

"""#4. Preprocessing the validation data"""

# preproceses the validation set

def preprocess_validation_examples(examples):
    questions = [q.strip() for q in examples["question"]]
    inputs = tokenizer(
        questions,
        examples["context"],
        max_length=max_length,
        truncation="only_second",
        stride=stride,
        return_overflowing_tokens=True,
        return_offsets_mapping=True,
        padding="max_length",
    )

    sample_map = inputs.pop("overflow_to_sample_mapping")
    example_ids = []

    for i in range(len(inputs["input_ids"])):
        sample_idx = sample_map[i]
        example_ids.append(examples["id"][sample_idx])

        sequence_ids = inputs.sequence_ids(i)
        offset = inputs["offset_mapping"][i]
        inputs["offset_mapping"][i] = [
            o if sequence_ids[k] == 1 else None for k, o in enumerate(offset)
        ]

    inputs["example_id"] = example_ids
    return inputs

validation_dataset = raw_datasets["validation"].map(
    preprocess_validation_examples,
    batched=True,
    remove_columns=raw_datasets["validation"].column_names,
)
len(raw_datasets["validation"]), len(validation_dataset)

"""#5. Fine-tuning the pretrained model

## Compute metrics
"""

!pip install evaluate

small_eval_set = raw_datasets["validation"].select(range(100))
trained_checkpoint = "distilbert-base-cased-distilled-squad"

tokenizer = AutoTokenizer.from_pretrained(trained_checkpoint)
eval_set = small_eval_set.map(
    preprocess_validation_examples,
    batched=True,
    remove_columns=raw_datasets["validation"].column_names,
)

tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)

import torch
from transformers import AutoModelForQuestionAnswering

eval_set_for_model = eval_set.remove_columns(["example_id", "offset_mapping"])
eval_set_for_model.set_format("torch")

device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
batch = {k: eval_set_for_model[k].to(device) for k in eval_set_for_model.column_names}
trained_model = AutoModelForQuestionAnswering.from_pretrained(trained_checkpoint).to(
    device
)

with torch.no_grad():
    outputs = trained_model(**batch)

start_logits = outputs.start_logits.cpu().numpy()
end_logits = outputs.end_logits.cpu().numpy()

import collections

example_to_features = collections.defaultdict(list)
for idx, feature in enumerate(eval_set):
    example_to_features[feature["example_id"]].append(idx)

import numpy as np

n_best = 20
max_answer_length = 30
predicted_answers = []

for example in small_eval_set:
    example_id = example["id"]
    context = example["context"]
    answers = []

    for feature_index in example_to_features[example_id]:
        start_logit = start_logits[feature_index]
        end_logit = end_logits[feature_index]
        offsets = eval_set["offset_mapping"][feature_index]

        start_indexes = np.argsort(start_logit)[-1 : -n_best - 1 : -1].tolist()
        end_indexes = np.argsort(end_logit)[-1 : -n_best - 1 : -1].tolist()
        for start_index in start_indexes:
            for end_index in end_indexes:
                # Skip answers that are not fully in the context
                if offsets[start_index] is None or offsets[end_index] is None:
                    continue
                # Skip answers with a length that is either < 0 or > max_answer_length.
                if (
                    end_index < start_index
                    or end_index - start_index + 1 > max_answer_length
                ):
                    continue

                answers.append(
                    {
                        "text": context[offsets[start_index][0] : offsets[end_index][1]],
                        "logit_score": start_logit[start_index] + end_logit[end_index],
                    }
                )

    best_answer = max(answers, key=lambda x: x["logit_score"])
    predicted_answers.append({"id": example_id, "prediction_text": best_answer["text"]})

import evaluate

metric = evaluate.load("squad")

theoretical_answers = [
    {"id": ex["id"], "answers": ex["answers"]} for ex in small_eval_set
]

print(predicted_answers[0])
print(theoretical_answers[0])

metric.compute(predictions=predicted_answers, references=theoretical_answers)

from tqdm.auto import tqdm


def compute_metrics(start_logits, end_logits, features, examples):
    example_to_features = collections.defaultdict(list)
    for idx, feature in enumerate(features):
        example_to_features[feature["example_id"]].append(idx)

    predicted_answers = []
    for example in tqdm(examples):
        example_id = example["id"]
        context = example["context"]
        answers = []

        # Loop through all features associated with that example
        for feature_index in example_to_features[example_id]:
            start_logit = start_logits[feature_index]
            end_logit = end_logits[feature_index]
            offsets = features[feature_index]["offset_mapping"]

            start_indexes = np.argsort(start_logit)[-1 : -n_best - 1 : -1].tolist()
            end_indexes = np.argsort(end_logit)[-1 : -n_best - 1 : -1].tolist()
            for start_index in start_indexes:
                for end_index in end_indexes:
                    # Skip answers that are not fully in the context
                    if offsets[start_index] is None or offsets[end_index] is None:
                        continue
                    # Skip answers with a length that is either < 0 or > max_answer_length
                    if (
                        end_index < start_index
                        or end_index - start_index + 1 > max_answer_length
                    ):
                        continue

                    answer = {
                        "text": context[offsets[start_index][0] : offsets[end_index][1]],
                        "logit_score": start_logit[start_index] + end_logit[end_index],
                    }
                    answers.append(answer)

        # Select the answer with the best score
        if len(answers) > 0:
            best_answer = max(answers, key=lambda x: x["logit_score"])
            predicted_answers.append(
                {"id": example_id, "prediction_text": best_answer["text"]}
            )
        else:
            predicted_answers.append({"id": example_id, "prediction_text": ""})

    theoretical_answers = [{"id": ex["id"], "answers": ex["answers"]} for ex in examples]
    return metric.compute(predictions=predicted_answers, references=theoretical_answers)

compute_metrics(start_logits, end_logits, eval_set, small_eval_set)

"""## Fine-tuning"""

from transformers import AutoModelForTokenClassification

model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)

# we set the batch size for the Training Arguments
batch_size = 16

from transformers import TrainingArguments

args = TrainingArguments(
    f"/content/drive/My Drive/APP1/xlm-roberta-qa-model-zero-shot",
    evaluation_strategy="no",
    save_strategy="epoch",
    learning_rate=5e-5, # '2e-5', in the tutorial
    per_device_train_batch_size=batch_size, # '8', by default
    per_device_eval_batch_size=batch_size, # '8' by default
    num_train_epochs=5, # '3', in the tutorial
    weight_decay=0.01,
    fp16=True,
)

from transformers import Trainer

trainer = Trainer(
    model=model,
    args=args,
    train_dataset=train_dataset,
    eval_dataset=validation_dataset,
    tokenizer=tokenizer,
)
trainer.train()

predictions, _, _ = trainer.predict(validation_dataset)
start_logits, end_logits = predictions
compute_metrics(start_logits, end_logits, validation_dataset, raw_datasets["validation"])

"""##OPTIONAL: customised training loop"""

from torch.utils.data import DataLoader
from transformers import default_data_collator

train_dataset.set_format("torch")
validation_set = validation_dataset.remove_columns(["example_id", "offset_mapping"])
validation_set.set_format("torch")

train_dataloader = DataLoader(
    train_dataset,
    shuffle=True,
    collate_fn=default_data_collator,
    batch_size=8,
)
eval_dataloader = DataLoader(
    validation_set, collate_fn=default_data_collator, batch_size=8
)

# we reinstantiate our model, to make sure we’re not continuing the fine-tuning from before 
# but starting from the initial pretrained model again

model_checkpoint = "projecte-aina/roberta-base-ca-v2"

model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)

from torch.optim import AdamW

optimizer = AdamW(model.parameters(), lr=2e-5)

!pip install accelerate

from accelerate import Accelerator

accelerator = Accelerator() # 'Accelerator(fp16=True)' -> ERROR, unexpected argument
model, optimizer, train_dataloader, eval_dataloader = accelerator.prepare(
    model, optimizer, train_dataloader, eval_dataloader
)

from transformers import get_scheduler

num_train_epochs = 3
num_update_steps_per_epoch = len(train_dataloader)
num_training_steps = num_train_epochs * num_update_steps_per_epoch

lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps,
)

output_dir = "/content/drive/My Drive/Colab Notebooks/EHU/APP1/berta-qa-model_customised"

from tqdm.auto import tqdm
import torch

progress_bar = tqdm(range(num_training_steps))

for epoch in range(num_train_epochs):
    # Training
    model.train()
    for step, batch in enumerate(train_dataloader):
        outputs = model(**batch)
        loss = outputs.loss
        accelerator.backward(loss)

        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)

    # Evaluation
    model.eval()
    start_logits = []
    end_logits = []
    accelerator.print("Evaluation!")
    for batch in tqdm(eval_dataloader):
        with torch.no_grad():
            outputs = model(**batch)

        start_logits.append(accelerator.gather(outputs.start_logits).cpu().numpy())
        end_logits.append(accelerator.gather(outputs.end_logits).cpu().numpy())

    start_logits = np.concatenate(start_logits)
    end_logits = np.concatenate(end_logits)
    start_logits = start_logits[: len(validation_dataset)]
    end_logits = end_logits[: len(validation_dataset)]

    metrics = compute_metrics(
        start_logits, end_logits, validation_dataset, raw_datasets["validation"]
    )
    print(f"epoch {epoch}:", metrics)

    # Save and upload
    accelerator.wait_for_everyone()
    unwrapped_model = accelerator.unwrap_model(model)
    unwrapped_model.save_pretrained(output_dir)
    if accelerator.is_main_process:
        tokenizer.save_pretrained(output_dir)

"""#6. Using the fine-tuned model"""

from transformers import pipeline

# Replace this with your own checkpoint
model_checkpoint = "/content/drive/My Drive/APP1/xlm-roberta-qa-model-zero-shot/checkpoint-5445"
question_answerer = pipeline("question-answering", model=model_checkpoint)

context = """
Noah Higón és de València, té 24 anys i des dels 12 que lluita per les malalties rares. 
Té dos llibres publicats narrant la seua història, forma part de diverses associacions i, 
ara serà el monument central de la Falla Tres Forques, el qual l’han titulat “Res és impossible”, 
frase que la jove té present al seu dia a dia.
"""
question = "Com es diu el monument de la Falla Tres Forques?"
answer = question_answerer(question=question, context=context)
print(answer)